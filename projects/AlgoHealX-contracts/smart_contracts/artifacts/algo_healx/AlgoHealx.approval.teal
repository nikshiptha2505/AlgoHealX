#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 32
    bytecblock "batch_count" "manufacturer_count" "owner" 0x6d616e755f 0x62617463685f
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/algo_healx/contract.py:18
    // self.batch_count = UInt64(0)
    bytec_0 // "batch_count"
    intc_0 // 0
    app_global_put
    // smart_contracts/algo_healx/contract.py:19
    // self.manufacturer_count = UInt64(0)
    bytec_1 // "manufacturer_count"
    intc_0 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/algo_healx/contract.py:7
    // class AlgoHealx(ARC4Contract):
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@9
    pushbytess 0x3b8eac99 0x8bd4b96d 0xc99642cc // method "add_manufacturer(address)void", method "register_batch(string)void", method "get_batch_details(uint64)string"
    txna ApplicationArgs 0
    match add_manufacturer register_batch get_batch_details
    err

main_create_NoOp@9:
    // smart_contracts/algo_healx/contract.py:7
    // class AlgoHealx(ARC4Contract):
    pushbytes 0xbb177320 // method "create_application(address,address)void"
    txna ApplicationArgs 0
    match create_application
    err


// smart_contracts.algo_healx.contract.AlgoHealx.create_application[routing]() -> void:
create_application:
    // smart_contracts/algo_healx/contract.py:21
    // @abimethod(allow_actions=["NoOp"], create="require")
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/algo_healx/contract.py:23
    // self.owner = owner_addr
    bytec_2 // "owner"
    uncover 2
    app_global_put
    // smart_contracts/algo_healx/contract.py:24
    // self.government_address = government_addr
    pushbytes "government_address"
    swap
    app_global_put
    // smart_contracts/algo_healx/contract.py:25
    // self.batch_count = UInt64(0)
    bytec_0 // "batch_count"
    intc_0 // 0
    app_global_put
    // smart_contracts/algo_healx/contract.py:26
    // self.manufacturer_count = UInt64(0)
    bytec_1 // "manufacturer_count"
    intc_0 // 0
    app_global_put
    // smart_contracts/algo_healx/contract.py:21
    // @abimethod(allow_actions=["NoOp"], create="require")
    intc_1 // 1
    return


// smart_contracts.algo_healx.contract.AlgoHealx.add_manufacturer[routing]() -> void:
add_manufacturer:
    // smart_contracts/algo_healx/contract.py:28
    // @abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/algo_healx/contract.py:30
    // assert self.manufacturer_count < UInt64(MAX_MANUFACTURERS), "Whitelist full"
    intc_0 // 0
    bytec_1 // "manufacturer_count"
    app_global_get_ex
    assert // check self.manufacturer_count exists
    dup
    pushint 50 // 50
    <
    assert // Whitelist full
    // smart_contracts/algo_healx/contract.py:31
    // assert Txn.sender == self.owner, "Unauthorized"
    txn Sender
    intc_0 // 0
    bytec_2 // "owner"
    app_global_get_ex
    assert // check self.owner exists
    ==
    assert // Unauthorized
    // smart_contracts/algo_healx/contract.py:33
    // self.manufacturers[idx] = manufacturer_addr
    dup
    itob
    bytec_3 // 0x6d616e755f
    swap
    concat
    uncover 2
    box_put
    // smart_contracts/algo_healx/contract.py:34
    // self.manufacturer_count = self.manufacturer_count + UInt64(1)
    intc_1 // 1
    +
    bytec_1 // "manufacturer_count"
    swap
    app_global_put
    // smart_contracts/algo_healx/contract.py:28
    // @abimethod()
    intc_1 // 1
    return


// smart_contracts.algo_healx.contract.AlgoHealx.register_batch[routing]() -> void:
register_batch:
    // smart_contracts/algo_healx/contract.py:36
    // @abimethod()
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    // smart_contracts/algo_healx/contract.py:46
    // i: UInt64 = UInt64(0)
    intc_0 // 0

register_batch_while_top@2:
    // smart_contracts/algo_healx/contract.py:47
    // while i < self.manufacturer_count:
    intc_0 // 0
    bytec_1 // "manufacturer_count"
    app_global_get_ex
    assert // check self.manufacturer_count exists
    dig 1
    >
    bz register_batch_after_while@6
    // smart_contracts/algo_healx/contract.py:48-51
    // # The knowledge sources do not provide a safe default if zero_address is unavailable.
    // # Using Account() is not documented as valid.
    // # If zero_address is available, use: m = self.manufacturers.get(i, default=zero_address)
    // m = self.manufacturers.get(i, default=Account("WMHF4FLJNKY2BPFK7YPV5ID6OZ7LVDB2B66ZTXEAMLL2NX4WJZRJFVX66M")) # No default provided
    dup
    itob
    bytec_3 // 0x6d616e755f
    swap
    concat
    box_get
    pushbytes base32(WMHF4FLJNKY2BPFK7YPV5ID6OZ7LVDB2B66ZTXEAMLL2NX4WJZRA) // addr WMHF4FLJNKY2BPFK7YPV5ID6OZ7LVDB2B66ZTXEAMLL2NX4WJZRJFVX66M
    cover 2
    select
    // smart_contracts/algo_healx/contract.py:52
    // if Txn.sender == m:
    txn Sender
    ==
    bz register_batch_after_if_else@5
    // smart_contracts/algo_healx/contract.py:53
    // return UInt64(1)
    intc_1 // 1

register_batch_after_inlined_smart_contracts.algo_healx.contract.AlgoHealx._is_sender_manufacturer@7:
    // smart_contracts/algo_healx/contract.py:38
    // assert self._is_sender_manufacturer() == UInt64(1), "Not whitelisted"
    intc_1 // 1
    ==
    assert // Not whitelisted
    // smart_contracts/algo_healx/contract.py:39
    // idx: UInt64 = self.batch_count
    intc_0 // 0
    bytec_0 // "batch_count"
    app_global_get_ex
    assert // check self.batch_count exists
    // smart_contracts/algo_healx/contract.py:40
    // assert idx < UInt64(MAX_BATCHES), "Batch limit reached"
    dup
    pushint 100 // 100
    <
    assert // Batch limit reached
    // smart_contracts/algo_healx/contract.py:41
    // self.batches[idx] = batch_details
    dup
    itob
    bytec 4 // 0x62617463685f
    swap
    concat
    dup
    box_del
    pop
    dig 3
    box_put
    // smart_contracts/algo_healx/contract.py:42
    // self.batch_count = self.batch_count + UInt64(1)
    intc_1 // 1
    +
    bytec_0 // "batch_count"
    swap
    app_global_put
    // smart_contracts/algo_healx/contract.py:36
    // @abimethod()
    intc_1 // 1
    return

register_batch_after_if_else@5:
    // smart_contracts/algo_healx/contract.py:54
    // i = i + UInt64(1)
    dup
    intc_1 // 1
    +
    bury 1
    b register_batch_while_top@2

register_batch_after_while@6:
    // smart_contracts/algo_healx/contract.py:55
    // return UInt64(0)
    intc_0 // 0
    // smart_contracts/algo_healx/contract.py:38
    // assert self._is_sender_manufacturer() == UInt64(1), "Not whitelisted"
    b register_batch_after_inlined_smart_contracts.algo_healx.contract.AlgoHealx._is_sender_manufacturer@7


// smart_contracts.algo_healx.contract.AlgoHealx.get_batch_details[routing]() -> void:
get_batch_details:
    // smart_contracts/algo_healx/contract.py:56
    // @abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/algo_healx/contract.py:58
    // assert index < self.batch_count, "Invalid index"
    intc_0 // 0
    bytec_0 // "batch_count"
    app_global_get_ex
    assert // check self.batch_count exists
    dig 1
    >
    assert // Invalid index
    // smart_contracts/algo_healx/contract.py:59
    // return self.batches.get(index, default=String(""))
    itob
    bytec 4 // 0x62617463685f
    swap
    concat
    box_get
    pushbytes ""
    cover 2
    select
    // smart_contracts/algo_healx/contract.py:56
    // @abimethod(readonly=True)
    dup
    len
    itob
    extract 6 2
    swap
    concat
    pushbytes 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return
